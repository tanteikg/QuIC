/******************************************
 * Name: QuICimage.c
 *
 * Author: Tan Teik Guan
 *
 * Copyright (c) 2020 Tan Teik Guan.
 * All rights reserved.
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Tan Teik Guan. The name of
 * Tan Teik Guan may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *****************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "q_emul.h"
#include "gifenc.h"

void usage(char * Cmd)
{

	printf("Usage: %s <numQubits> <algorithm> <output gif filename>\n", Cmd);
	printf("e.g. %s 2 HH (to hadamard both qubits)\n     %s 2 HI,CN. (to create a bell state)\n",Cmd, Cmd);
	printf("     %s 3 HHX,ICN,CIN,HHH. or %s 3 HII,CNI,ICN. (to create the GHZ)\n",Cmd,Cmd);
	printf("     %s 3 HHI,IIX,IIH,III,CCN,III,IIH,IIX,HHI,XXI,IHI,CNI,IHI,XXI,HHI. (to perform a 2 qubit grover)\n",Cmd);
	printf("     %s 4 HHHI,IIIX,IIIH,IIII,CCCN,IIII,IIIH,IIIX,HHHI,XXXI,IIHI,CCNI,IIHI,XXXI,HHHI,IIIX,IIIH,IIII,CCCN,IIII,IIIH,IIIX,HHHI,XXXI,IIHI,CCNI,IIHI,XXXI,HHHI. (to perform a 3 qubit grover)\n", Cmd);
	printf("     %s 5 IIIIX,IHHHH,CIIIN,IHHHH,ImIII. (constant deutsche jozsa)\n", Cmd);
	printf("     %s 4 HHII,CINI,CIIN,ICNI,ICIN,IImm,HHII,mmII. (simon's algorithm for s=11)\n",Cmd);
	printf("     %s 5 IIIX,HHHH,CIIN,ICIN,IICN,HHHH,mIII (balanced deutsche jozsa)\n", Cmd);
	printf("     %s 8 XIXIXIII,nn***===. (to calculate 2 * 5) \n",Cmd);
	printf("     %s 12 XXHHXXIXIIII,nn^^%%%%====. (to calculate 3^i mod 13 where 0 < i < 3)\n",Cmd);
	printf("     %s 2 XX,ff,ss (2 Qubit QFT)\n", Cmd);
	printf("     %s 5 HHHII,IICNI,IICIN,IHIII,PCIII,HIIII,ICTII,CIPII (3 Qubit Shor\n", Cmd);
	printf("     %s 7 HHHIIII,IICINII,IICIINI,IIICINI,ICINICI,IIICINI,IIIINIC,ICIICIN,HIIIIII,CPIIIII,IHIIIII,CITIIII,ICPIIII,IIHIIII (factoring 15 using 3 Qubit Shor [Vandersypen et al])\n", Cmd);
	printf("Notes: 1. 0 < numQubits < %d\n",MAX_QUBITS);
	printf("       2. Valid gates are H (Hadamard), I (Identity), X (Not), CN (Control-Not), P (Phase), T (PI/8), s (SWAP), f (QFT) \n"); 
	printf("          Valid Oracle operations are *,/,+,-,^,%% (multiply, divide, add, subtract, power, modulo). Use n for 1st parameter, operation for 2nd parameter and = for result \n"); 
	printf("          Valid measurements are 0 (to continue when 0 is measured) and 1 (when 1 is measured) or use m for random measure\n"); 
	printf("          Others: d to delete a qubit, c to clone a qubit \n");
	printf("       3. Use _ as delimiter instead of , to print intermediate result, . to end\n"); 
}

int main(int argc, char * argv[])
{
	int numQubits = 0;
	int i;
	int done = 0;
	char nextGate[MAX_QUBITS+1];
	char * AlgoStr;
	int mask = 1;
	QState * qList = NULL;
	float Probability = 1.0;
	char outString[10000];
	char algoBuf[10000];
	
	printf("QuICimage version %1.2f\n",(float)qEmul_Version()/100.0);
	printf("-----------------\n");

	if (argc != 4)
	{
		usage(argv[0]);
		return -1; 
	}

	numQubits = atoi(argv[1]);
	if ((numQubits <= 0) || (numQubits > MAX_QUBITS))
	{
		usage(argv[0]);
		return -1;
	}
	else if ((numQubits > 8) || (numQubits == 5) || (numQubits == 7))
	{
		printf("Number of Qubits supported is 1, 2, 3, 4, 6 & 8\n");
		return -1;
	}

	AlgoStr = argv[2];
	
	qEmul_CreateList(&qList);

	while (!done)
	{
		if (strlen(AlgoStr) < numQubits)
		{
			if (*AlgoStr == DELIM_END)
			{
				done = 1;
				continue;
			}
			else if (*AlgoStr == DELIM_PRINT)
			{
				memset(outString,0,sizeof(outString));
				qEmul_PrintList(numQubits, qList,outString,sizeof(outString)-strlen(outString)-1);
				printf("%s",outString);
			}
			memset(algoBuf,0,sizeof(algoBuf));
			printf("more gates ? _ to print, . to end-> ");
			scanf("%s",algoBuf);
			AlgoStr = algoBuf;
			if (strlen(AlgoStr) < numQubits)
			{
				continue;
			}
				
		}
		memset(nextGate,0,sizeof(nextGate));
		memcpy(nextGate,AlgoStr,numQubits);	
		AlgoStr += numQubits;
		numQubits = qEmul_exec(numQubits,nextGate,&qList);
		if (*AlgoStr != '\0')
		{
			if (*AlgoStr == DELIM_PRINT)
			{
				memset(outString,0,sizeof(outString));
				sprintf(outString,"completed gate %s\n",nextGate);
				qEmul_PrintList(numQubits, qList,outString,sizeof(outString)-strlen(outString)-1);
				printf("%s",outString);
			}
			else if (*AlgoStr == DELIM_END)
			{
				done = 1;
				continue;
			}
			
			AlgoStr++;
		}

	}

/*
	if ((Probability = qEmul_GetProbability())< 1.0)
		printf("probability of result is : %2.1f%% \n",Probability*100);
	memset(outString,0,sizeof(outString));
	qEmul_PrintList(numQubits,qList,outString,sizeof(outString)-1);
	printf("%s",outString);
*/
	// create gif
	{
		uint8_t palette1[] = {
			0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF};
		uint8_t palette2[] = {
			0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF};
		uint8_t palette3[] = {
			0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00,
			0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
		uint8_t palette4[] = {
			0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x03, 0xF0, 0x00, 0xFF, 0xF0, 0x00,
			0x00, 0x0F, 0xC0, 0xFC, 0x0F, 0xC0, 0x03, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0,
			0x00, 0x00, 0x3F, 0xFC, 0x00, 0x3F, 0x03, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F,
			0x00, 0x0F, 0xFF, 0xFC, 0x0F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
		uint8_t palette6[] = {
			0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x00, 0x00, 0xFF, 0x00, 0x00, 
			0x00, 0xF0, 0x00, 0xF0, 0xF0, 0x00, 0x0F, 0xF0, 0x00, 0xFF, 0xF0, 0x00, 
			0x00, 0x0F, 0x00, 0xF0, 0x0F, 0x00, 0x0F, 0x0F, 0x00, 0xFF, 0x0F, 0x00, 
			0x00, 0xFF, 0x00, 0xF0, 0xFF, 0x00, 0x0F, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 
			0x00, 0x00, 0xF0, 0xF0, 0x00, 0xF0, 0x0F, 0x00, 0xF0, 0xFF, 0x00, 0xF0,
			0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 
			0x00, 0x0F, 0xF0, 0xF0, 0x0F, 0xF0, 0x0F, 0x0F, 0xF0, 0xFF, 0x0F, 0xF0, 
			0x00, 0xFF, 0xF0, 0xF0, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0xFF, 0xFF, 0xF0, 
			0x00, 0x00, 0x0F, 0xF0, 0x00, 0x0F, 0x0F, 0x00, 0x0F, 0xFF, 0x00, 0x0F, 
			0x00, 0xF0, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F, 0xF0, 0x0F, 0xFF, 0xF0, 0x0F,
			0x00, 0x0F, 0x0F, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0x0F, 0x0F, 
			0x00, 0xFF, 0x0F, 0xF0, 0xFF, 0x0F, 0x0F, 0xFF, 0x0F, 0xFF, 0xFF, 0x0F, 
			0x00, 0x00, 0xFF, 0xF0, 0x00, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 
			0x00, 0xF0, 0xFF, 0xF0, 0xF0, 0xFF, 0x0F, 0xF0, 0xFF, 0xFF, 0xF0, 0xFF, 
			0x00, 0x0F, 0xFF, 0xF0, 0x0F, 0xFF, 0x0F, 0x0F, 0xFF, 0xFF, 0x0F, 0xFF,
			0x00, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 
		uint8_t palette8[] = {
			0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x1C, 0x00, 0x00, 0xFC, 0x00, 0x00,
			0x03, 0x80, 0x00, 0xE3, 0x80, 0x00, 0x1F, 0x80, 0x00, 0xFF, 0x80, 0x00,
			0x00, 0x70, 0x00, 0xE0, 0x70, 0x00, 0x1C, 0x70, 0x00, 0xFC, 0x70, 0x00,
			0x03, 0xF0, 0x00, 0xE3, 0xF0, 0x00, 0x1F, 0xF0, 0x00, 0xFF, 0xF0, 0x00,
			0x00, 0x0E, 0x00, 0xE0, 0x0E, 0x00, 0x1C, 0x0E, 0x00, 0xFC, 0x0E, 0x00,
			0x03, 0x8E, 0x00, 0xE3, 0x8E, 0x00, 0x1F, 0x8E, 0x00, 0xFF, 0x8E, 0x00,
			0x00, 0x7E, 0x00, 0xE0, 0x7E, 0x00, 0x1C, 0x7E, 0x00, 0xFC, 0x7E, 0x00,
			0x03, 0xFE, 0x00, 0xE3, 0xFE, 0x00, 0x1F, 0xFE, 0x00, 0xFF, 0xFE, 0x00,
			0x00, 0x01, 0xC0, 0xE0, 0x01, 0xC0, 0x1C, 0x01, 0xC0, 0xFC, 0x01, 0xC0,
			0x03, 0x81, 0xC0, 0xE3, 0x81, 0xC0, 0x1F, 0x81, 0xC0, 0xFF, 0x81, 0xC0,
			0x00, 0x71, 0xC0, 0xE0, 0x71, 0xC0, 0x1C, 0x71, 0xC0, 0xFC, 0x71, 0xC0,
			0x03, 0xF1, 0xC0, 0xE3, 0xF1, 0xC0, 0x1F, 0xF1, 0xC0, 0xFF, 0xF1, 0xC0,
			0x00, 0x0F, 0xC0, 0xE0, 0x0F, 0xC0, 0x1C, 0x0F, 0xC0, 0xFC, 0x0F, 0xC0,
			0x03, 0x8F, 0xC0, 0xE3, 0x8F, 0xC0, 0x1F, 0x8F, 0xC0, 0xFF, 0x8F, 0xC0,
			0x00, 0x7F, 0xC0, 0xE0, 0x7F, 0xC0, 0x1C, 0x7F, 0xC0, 0xFC, 0x7F, 0xC0,
			0x03, 0xFF, 0xC0, 0xE3, 0xFF, 0xC0, 0x1F, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0,
			0x00, 0x00, 0x38, 0xE0, 0x00, 0x38, 0x1C, 0x00, 0x38, 0xFC, 0x00, 0x38,
			0x03, 0x80, 0x38, 0xE3, 0x80, 0x38, 0x1F, 0x80, 0x38, 0xFF, 0x80, 0x38,
			0x00, 0x70, 0x38, 0xE0, 0x70, 0x38, 0x1C, 0x70, 0x38, 0xFC, 0x70, 0x38,
			0x03, 0xF0, 0x38, 0xE3, 0xF0, 0x38, 0x1F, 0xF0, 0x38, 0xFF, 0xF0, 0x38,
			0x00, 0x0E, 0x38, 0xE0, 0x0E, 0x38, 0x1C, 0x0E, 0x38, 0xFC, 0x0E, 0x38,
			0x03, 0x8E, 0x38, 0xE3, 0x8E, 0x38, 0x1F, 0x8E, 0x38, 0xFF, 0x8E, 0x38,
			0x00, 0x7E, 0x38, 0xE0, 0x7E, 0x38, 0x1C, 0x7E, 0x38, 0xFC, 0x7E, 0x38,
			0x03, 0xFE, 0x38, 0xE3, 0xFE, 0x38, 0x1F, 0xFE, 0x38, 0xFF, 0xFE, 0x38,
			0x00, 0x01, 0xF8, 0xE0, 0x01, 0xF8, 0x1C, 0x01, 0xF8, 0xFC, 0x01, 0xF8,
			0x03, 0x81, 0xF8, 0xE3, 0x81, 0xF8, 0x1F, 0x81, 0xF8, 0xFF, 0x81, 0xF8,
			0x00, 0x71, 0xF8, 0xE0, 0x71, 0xF8, 0x1C, 0x71, 0xF8, 0xFC, 0x71, 0xF8,
			0x03, 0xF1, 0xF8, 0xE3, 0xF1, 0xF8, 0x1F, 0xF1, 0xF8, 0xFF, 0xF1, 0xF8,
			0x00, 0x0F, 0xF8, 0xE0, 0x0F, 0xF8, 0x1C, 0x0F, 0xF8, 0xFC, 0x0F, 0xF8,
			0x03, 0x8F, 0xF8, 0xE3, 0x8F, 0xF8, 0x1F, 0x8F, 0xF8, 0xFF, 0x8F, 0xF8,
			0x00, 0x7F, 0xF8, 0xE0, 0x7F, 0xF8, 0x1C, 0x7F, 0xF8, 0xFC, 0x7F, 0xF8,
			0x03, 0xFF, 0xF8, 0xE3, 0xFF, 0xF8, 0x1F, 0xFF, 0xF8, 0xFF, 0xFF, 0xF8,
			0x00, 0x00, 0x07, 0xE0, 0x00, 0x07, 0x1C, 0x00, 0x07, 0xFC, 0x00, 0x07,
			0x03, 0x80, 0x07, 0xE3, 0x80, 0x07, 0x1F, 0x80, 0x07, 0xFF, 0x80, 0x07,
			0x00, 0x70, 0x07, 0xE0, 0x70, 0x07, 0x1C, 0x70, 0x07, 0xFC, 0x70, 0x07,
			0x03, 0xF0, 0x07, 0xE3, 0xF0, 0x07, 0x1F, 0xF0, 0x07, 0xFF, 0xF0, 0x07,
			0x00, 0x0E, 0x07, 0xE0, 0x0E, 0x07, 0x1C, 0x0E, 0x07, 0xFC, 0x0E, 0x07,
			0x03, 0x8E, 0x07, 0xE3, 0x8E, 0x07, 0x1F, 0x8E, 0x07, 0xFF, 0x8E, 0x07,
			0x00, 0x7E, 0x07, 0xE0, 0x7E, 0x07, 0x1C, 0x7E, 0x07, 0xFC, 0x7E, 0x07,
			0x03, 0xFE, 0x07, 0xE3, 0xFE, 0x07, 0x1F, 0xFE, 0x07, 0xFF, 0xFE, 0x07,
			0x00, 0x01, 0xC7, 0xE0, 0x01, 0xC7, 0x1C, 0x01, 0xC7, 0xFC, 0x01, 0xC7,
			0x03, 0x81, 0xC7, 0xE3, 0x81, 0xC7, 0x1F, 0x81, 0xC7, 0xFF, 0x81, 0xC7,
			0x00, 0x71, 0xC7, 0xE0, 0x71, 0xC7, 0x1C, 0x71, 0xC7, 0xFC, 0x71, 0xC7,
			0x03, 0xF1, 0xC7, 0xE3, 0xF1, 0xC7, 0x1F, 0xF1, 0xC7, 0xFF, 0xF1, 0xC7,
			0x00, 0x0F, 0xC7, 0xE0, 0x0F, 0xC7, 0x1C, 0x0F, 0xC7, 0xFC, 0x0F, 0xC7,
			0x03, 0x8F, 0xC7, 0xE3, 0x8F, 0xC7, 0x1F, 0x8F, 0xC7, 0xFF, 0x8F, 0xC7,
			0x00, 0x7F, 0xC7, 0xE0, 0x7F, 0xC7, 0x1C, 0x7F, 0xC7, 0xFC, 0x7F, 0xC7,
			0x03, 0xFF, 0xC7, 0xE3, 0xFF, 0xC7, 0x1F, 0xFF, 0xC7, 0xFF, 0xFF, 0xC7,
			0x00, 0x00, 0x3F, 0xE0, 0x00, 0x3F, 0x1C, 0x00, 0x3F, 0xFC, 0x00, 0x3F,
			0x03, 0x80, 0x3F, 0xE3, 0x80, 0x3F, 0x1F, 0x80, 0x3F, 0xFF, 0x80, 0x3F,
			0x00, 0x70, 0x3F, 0xE0, 0x70, 0x3F, 0x1C, 0x70, 0x3F, 0xFC, 0x70, 0x3F,
			0x03, 0xF0, 0x3F, 0xE3, 0xF0, 0x3F, 0x1F, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F,
			0x00, 0x0E, 0x3F, 0xE0, 0x0E, 0x3F, 0x1C, 0x0E, 0x3F, 0xFC, 0x0E, 0x3F,
			0x03, 0x8E, 0x3F, 0xE3, 0x8E, 0x3F, 0x1F, 0x8E, 0x3F, 0xFF, 0x8E, 0x3F,
			0x00, 0x7E, 0x3F, 0xE0, 0x7E, 0x3F, 0x1C, 0x7E, 0x3F, 0xFC, 0x7E, 0x3F,
			0x03, 0xFE, 0x3F, 0xE3, 0xFE, 0x3F, 0x1F, 0xFE, 0x3F, 0xFF, 0xFE, 0x3F,
			0x00, 0x01, 0xFF, 0xE0, 0x01, 0xFF, 0x1C, 0x01, 0xFF, 0xFC, 0x01, 0xFF,
			0x03, 0x81, 0xFF, 0xE3, 0x81, 0xFF, 0x1F, 0x81, 0xFF, 0xFF, 0x81, 0xFF,
			0x00, 0x71, 0xFF, 0xE0, 0x71, 0xFF, 0x1C, 0x71, 0xFF, 0xFC, 0x71, 0xFF,
			0x03, 0xF1, 0xFF, 0xE3, 0xF1, 0xFF, 0x1F, 0xF1, 0xFF, 0xFF, 0xF1, 0xFF,
			0x00, 0x0F, 0xFF, 0xE0, 0x0F, 0xFF, 0x1C, 0x0F, 0xFF, 0xFC, 0x0F, 0xFF,
			0x03, 0x8F, 0xFF, 0xE3, 0x8F, 0xFF, 0x1F, 0x8F, 0xFF, 0xFF, 0x8F, 0xFF,
			0x00, 0x7F, 0xFF, 0xE0, 0x7F, 0xFF, 0x1C, 0x7F, 0xFF, 0xFC, 0x7F, 0xFF,
			0x03, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
		int w = 256, h = 256;
		int i,j,k,k1;
		unsigned long colourblock[256] = {0};

		uint8_t * palette = NULL;	
		if (numQubits == 1)
			palette = palette1;
		else if (numQubits == 2)
			palette = palette2;
		else if (numQubits == 3)
			palette = palette3;
		else if (numQubits == 4)
			palette = palette4;
		else if (numQubits == 6)
			palette = palette6;
		else if (numQubits == 8)
			palette = palette8;
		ge_GIF *gif = ge_new_gif(argv[3], w, h, palette, numQubits, -1, 0);

		qEmul_PrintBlock(numQubits,qList,colourblock,256);

		for (i = 0; i < w*h; i++)
			gif->frame[i] = 0; // starting block
// for printing square		
/*
		for (i = 0; i < numQubits; i++)
			for (k = 0; k < (256/numQubits); k++)
				for (j = 0; j < (256/numQubits); j++)
				{
					for (k1=0;k1<numQubits;k1++)
					{
						gif->frame[i*256*(256/numQubits) + k*256 + j*numQubits + k1] = colourblock[i*(256/numQubits)+j];
					}
				}
*/
// for printing diagonals
		for (i=0; i < 256; i++)
		{
			k = i;
			for (j=0; j<=i;j++)
			{
				gif->frame[k*256+j] = colourblock[(i*256+j)/(2*256)];
				k--;
			}
			if ((i % 10) == 0)
			{
				void * tmp;
				ge_add_frame(gif,1);
				tmp = gif->back;
				gif->back = gif->frame;
				gif->frame=tmp;
			}
		}
		
		for (j=1; j < 256; j++)
		{
			k=j;
			for (i=255;i>=j;i--)
			{
				gif->frame[i*256+k] = colourblock[127+(j*256+(255-i))/(2*256)];
				k++;
			}
			if ((j % 10) == 0)
			{
				void * tmp;
				ge_add_frame(gif,1);
				tmp = gif->back;
				gif->back = gif->frame;
				gif->frame=tmp;
			}
		}
		
		ge_add_frame(gif,100);

		ge_close_gif(gif);		
		
		printf("image written to %s \n",argv[3]);

	}
	qEmul_FreeList(qList);
	
	return 0;

	
}

